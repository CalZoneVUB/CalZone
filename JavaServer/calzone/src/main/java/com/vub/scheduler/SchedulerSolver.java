package com.vub.scheduler;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Set;

import org.optaplanner.core.api.solver.Solver;
import org.optaplanner.core.config.solver.XmlSolverFactory;
import org.optaplanner.core.impl.score.director.ScoreDirector;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vub.model.Course;
import com.vub.model.CourseComponent;
import com.vub.model.Entry;
import com.vub.model.Room;
import com.vub.model.Traject;

/**
 * Class which acts as an extra abstraction layer above the 'Solver' class from
 * the optaplanner API.
 * 
 * This class starts mainly from an traject list to schedule.
 * 
 * <p>
 * This class also acts as a service to the drools rule engine to get the
 * collection of trajects.
 * </p>
 * 
 * @author pieter
 * 
 */
public class SchedulerSolver extends SchedulerScoreCalculator {
	private List<Date> startDateList;
	private List<Room> roomList;
	private List<Entry> entryList;
	private Set<Traject> trajectList = null;

	/**
	 * Constructs a SchedulerSolver instance. This object is automaticcaly added
	 * to the working memory, so that it can be used by the drools rule engine.
	 * 
	 * @param startDateList
	 *            The available date slots that can be used for scheduling.
	 * @param roomList
	 *            The available rooms that can be used for scheduling.
	 * @param trajectList
	 *            The trajects that needs to be scheduled.
	 */
	public SchedulerSolver(List<Date> startDateList, List<Room> roomList,
			Set<Traject> trajectList) {
		super(new Scheduler(startDateList, roomList,
				SchedulerSolver.createEntryList(startDateList, roomList,
						trajectList), trajectList));
		this.startDateList = startDateList;
		this.roomList = roomList;
		this.entryList = SchedulerSolver.createEntryList(startDateList,
				roomList, trajectList);
		this.trajectList = trajectList;
	}
	
	/**
	 * This method should be invoked to start a scheduling. The method blocks
	 * until an optimal solution is found.
	 * 
	 * @return the best solution generated by the solver of optaplanner.
	 */
	public Scheduler run() {
		solver.solve();
		super.setScheduler((Scheduler) solver.getBestSolution());
		return super.getScheduler();
	}

	/**
	 * @return the trajectList
	 */
	public Set<Traject> getTrajectList() {
		return trajectList;
	}

	// TODO remove static in some manner ?
	public static List<Entry> createEntryList(List<Date> startDateList,
			List<Room> roomList, Set<Traject> trajectList) {
		List<Entry> entryList = new ArrayList<Entry>();
		for (Traject traject : trajectList) {
			for (Course c : traject.getCourses()) {
				for (CourseComponent cc : c.getCourseComponents()) {
					int duration = cc.getDuration();
					int contactHours = cc.getContactHours();

					int indexInCourseComponent = 0;
					for (int currentTotalContactHours = 0; currentTotalContactHours < contactHours; currentTotalContactHours += duration) {
						Entry entry = new Entry();
						entry.setStartingDate(startDateList.get(0));
						entry.setRoom(roomList.get(0));
						entry.setCourseComponent(cc);
						entry.setFrozen(false);
						entry.setIndexInCourseComponent(indexInCourseComponent);
						entryList.add(entry);

						indexInCourseComponent++;
					}
				}
			}
		}

		return entryList;
	}
}
