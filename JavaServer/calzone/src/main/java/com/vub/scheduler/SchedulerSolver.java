package com.vub.scheduler;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Set;

import org.apache.commons.collections.ListUtils;
import org.optaplanner.core.api.solver.Solver;
import org.optaplanner.core.config.solver.XmlSolverFactory;
import org.optaplanner.core.impl.score.director.ScoreDirector;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vub.model.Course;
import com.vub.model.CourseComponent;
import com.vub.model.Entry;
import com.vub.model.Room;
import com.vub.model.Traject;
import com.vub.model.CourseComponent.CourseComponentTerm;

/**
 * Class which acts as an extra abstraction layer above the 'Solver' class from
 * the optaplanner API.
 * 
 * This class starts mainly from an traject list to schedule.
 * 
 * @author Pieter Meiresone
 * 
 */
public class SchedulerSolver extends SchedulerScoreCalculator {
	private List<Room> roomList;
	private List<Entry> entryList;
	private Set<Traject> trajectSet = null;
	private int academicYearStart;

	public SchedulerSolver(int academicYearStart, List<Room> roomList,
			Set<Traject> trajectSet) {
		super();
		this.roomList = roomList;
		this.trajectSet = trajectSet;
		this.academicYearStart = academicYearStart;
	}

	/**
	 * Constructs a SchedulerSolver instance.
	 * 
	 * @param startDateList
	 *            The available date slots that can be used for scheduling.
	 * @param roomList
	 *            The available rooms that can be used for scheduling.
	 * @param trajectList
	 *            The trajects that needs to be scheduled.
	 */
	@Deprecated
	public SchedulerSolver(List<Date> startDateList, List<Room> roomList,
			Set<Traject> trajectList) {
		super(new Scheduler(startDateList, roomList,
				SchedulerSolver.createEntryList(startDateList, roomList,
						trajectList), trajectList));
		this.roomList = roomList;
		this.entryList = SchedulerSolver.createEntryList(startDateList,
				roomList, trajectList);
		this.trajectSet = trajectList;
	}

	/**
	 * This method should be invoked to start a scheduling. The method blocks
	 * until an optimal solution is found.
	 * 
	 * @return the best solution generated by the solver of optaplanner.
	 */
	public Scheduler run() {
		// Schedule term 1
		List<Date> startDateListTerm1 = SchedulerInitializer.createSlotsOfTerm(
				academicYearStart, 1);
		List<Entry> entryListTerm1 = this.createEntryList(startDateListTerm1,
				roomList, trajectSet, 1, (academicYearStart % 2) != 0);
		Scheduler term1 = new Scheduler(startDateListTerm1, roomList,
				entryListTerm1, trajectSet);
		super.setScheduler(term1);

		solver.solve();
		Scheduler solutionTerm1 = (Scheduler) solver.getBestSolution();

		// Schedule term 2
		List<Date> startDateListTerm2 = SchedulerInitializer.createSlotsOfTerm(
				academicYearStart, 2);
		List<Entry> entryListTerm2 = this.createEntryList(startDateListTerm2,
				roomList, trajectSet, 2, (academicYearStart % 2) != 0);
		Scheduler term2 = new Scheduler(startDateListTerm2, roomList,
				entryListTerm2, trajectSet);
		super.setScheduler(term2);

		solver.solve();
		Scheduler solutionTerm2 = (Scheduler) solver.getBestSolution();

		// Combine into schedule combined terms
		List<Date> startDateListYear = new ArrayList<Date>();
		startDateListYear.addAll(startDateListTerm1);
		startDateListYear.addAll(startDateListTerm2);
		List<Entry> entryListYear = new ArrayList<Entry>();
		entryListYear.addAll(solutionTerm1.getEntryList());
		entryListYear.addAll(solutionTerm2.getEntryList());
		
		Scheduler solutionYear = new Scheduler(startDateListYear, roomList,
				entryListYear, trajectSet);

		super.setScheduler(solutionYear);
		return super.getScheduler();
	}
	/**
	 * @return the trajectList
	 */
	public Set<Traject> getTrajectList() {
		return trajectSet;
	}

	private List<Entry> createEntryList(List<Date> dateList,
			List<Room> roomList, Set<Traject> trajectSet, int term,
			boolean oddYear) {
		List<Entry> entryList = new ArrayList<Entry>();
		for (Traject traject : trajectSet) {
			for (Course c : traject.getCourses()) {
				for (CourseComponent cc : c.getCourseComponents()) {
					if (term == 1
							&& (cc.getTerm() == CourseComponentTerm.S1
									|| (cc.getTerm() == CourseComponentTerm.S4 && oddYear) || (cc
									.getTerm() == CourseComponentTerm.S7 && !oddYear))) {
						// Schedule for first semester and course is given
						// entirely during first semester
						int duration = cc.getDuration();
						int contactHours = cc.getContactHours();

						int indexInCourseComponent = 0;
						for (int currentTotalContactHours = 0; currentTotalContactHours < contactHours; currentTotalContactHours += duration) {
							Entry entry = new Entry();
							entry.setStartingDate(dateList.get(0));
							entry.setRoom(roomList.get(0));
							entry.setCourseComponent(cc);
							entry.setFrozen(false);
							entry.setIndexInCourseComponent(indexInCourseComponent);
							entryList.add(entry);

							indexInCourseComponent++;
						}
					} else if (term == 2
							&& (cc.getTerm() == CourseComponentTerm.S2
									|| (cc.getTerm() == CourseComponentTerm.S5 && oddYear) || (cc
									.getTerm() == CourseComponentTerm.S8 && !oddYear))) {
						// Schedule for second semester and course is given
						// entirely during second semester
						int duration = cc.getDuration();
						int contactHours = cc.getContactHours();

						int indexInCourseComponent = 0;
						for (int currentTotalContactHours = 0; currentTotalContactHours < contactHours; currentTotalContactHours += duration) {
							Entry entry = new Entry();
							entry.setStartingDate(dateList.get(0));
							entry.setRoom(roomList.get(0));
							entry.setCourseComponent(cc);
							entry.setFrozen(false);
							entry.setIndexInCourseComponent(indexInCourseComponent);
							entryList.add(entry);

							indexInCourseComponent++;
						}
					} else if (term == 1
							&& (cc.getTerm() == CourseComponentTerm.S3
									|| (cc.getTerm() == CourseComponentTerm.S6 && oddYear) || (cc
									.getTerm() == CourseComponentTerm.S9 && !oddYear))) {
						// First semester and course is given during both
						// semesters
						int duration = cc.getDuration();
						int contactHours = Math.round(cc.getContactHours());
						int totalNumberOfEntries = (int) Math.round(duration
								/ (float) contactHours);

						for (int index = 0; index < totalNumberOfEntries / 2; index++) {
							Entry entry = new Entry();
							entry.setStartingDate(dateList.get(0));
							entry.setRoom(roomList.get(0));
							entry.setCourseComponent(cc);
							entry.setFrozen(false);
							entry.setIndexInCourseComponent(index);
							entryList.add(entry);
						}
					} else if (term == 2
							&& (cc.getTerm() == CourseComponentTerm.S3
									|| (cc.getTerm() == CourseComponentTerm.S6 && oddYear) || (cc
									.getTerm() == CourseComponentTerm.S9 && !oddYear))) {
						// Second semester and course is given during both
						// semesters
						int duration = cc.getDuration();
						int contactHours = Math.round(cc.getContactHours());
						int totalNumberOfEntries = (int) Math.round(duration
								/ (float) contactHours);

						for (int index = totalNumberOfEntries / 2; index < totalNumberOfEntries; index++) {
							Entry entry = new Entry();
							entry.setStartingDate(dateList.get(0));
							entry.setRoom(roomList.get(0));
							entry.setCourseComponent(cc);
							entry.setFrozen(false);
							entry.setIndexInCourseComponent(index);
							entryList.add(entry);
						}
					}

				}
			}
		}

		return entryList;
	}
	// TODO remove static in some manner ?
	public static List<Entry> createEntryList(List<Date> startDateList,
			List<Room> roomList, Set<Traject> trajectList) {
		List<Entry> entryList = new ArrayList<Entry>();
		for (Traject traject : trajectList) {
			for (Course c : traject.getCourses()) {
				for (CourseComponent cc : c.getCourseComponents()) {
					int duration = cc.getDuration();
					int contactHours = cc.getContactHours();

					int indexInCourseComponent = 0;
					for (int currentTotalContactHours = 0; currentTotalContactHours < contactHours; currentTotalContactHours += duration) {
						Entry entry = new Entry();
						entry.setStartingDate(startDateList.get(0));
						entry.setRoom(roomList.get(0));
						entry.setCourseComponent(cc);
						entry.setFrozen(false);
						entry.setIndexInCourseComponent(indexInCourseComponent);
						entryList.add(entry);

						indexInCourseComponent++;
					}
				}
			}
		}

		return entryList;
	}
}
